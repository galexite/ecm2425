@file:Suppress("UnstableApiUsage", "SpellCheckingInspection")

package uk.galexite.guildevents.network

import android.util.Log
import com.google.common.hash.Hashing
import okhttp3.Headers
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.IOException
import java.nio.charset.Charset
import java.text.SimpleDateFormat
import java.util.*

/**
 * A group of static methods for accessing the data which is stored in the cloud (in Amazon S3).
 * Used by the UpdateDatabaseAsyncTask to load fresh data in to the database when the
 * EventListActivity is run.
 */
internal object GuildEventsS3 {
    private const val TAG = "GuildEventsS3"
    private const val BUCKET_REGION = "your-region-identifier"
    private const val BUCKET_HOST = "your-s3-bucket.amazonaws.com"
    private const val BUCKET_URL = "https://your-s3-bucket-url.amazonaws.com/"
    private const val API_KEY = ""
    private const val ACCESS_KEY = ""

    // As the hash for an empty payload (i.e. no upload) is the same in SHA256, we can store the
    // hash here and not worry about generating it.
    private const val EMPTY_PAYLOAD_HASH =
        "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    private val okHttpClient = OkHttpClient()

    /**
     * Generate the HTTP 'Authorization' header for connecting to S3.
     *
     * Yes, this is incredibly and annoyingly complicated... but that's the way Amazon has designed
     * authorisation to S3 buckets in AWS.
     * Based on https://czak.pl/2015/09/15/s3-rest-api-with-curl.html
     *
     * @param path the path of the object in the bucket
     * @param amzDate String representing the date the request was made
     * @param method the HTTP method used to make the request
     * @return the HTTP Authorization header
     */
    private fun getAuthorisationHeader(path: String, amzDate: String, method: String): String {
        // The list of headers that we will send to the S3 server as part of making the request.
        val canonical = String.format(
            """
              %s
              /%s
              
              host:%s
              x-amz-content-sha256:%s
              x-amz-date:%s
              
              host;x-amz-content-sha256;x-amz-date
              %s
              """.trimIndent(),
            method, path, BUCKET_HOST, EMPTY_PAYLOAD_HASH, amzDate, EMPTY_PAYLOAD_HASH
        )

        // HTTP is UTF-8 encoded, so we will encode all byte data in this charset.
        val utf8 = Charset.forName("UTF-8")
        val messageDigest = Hashing.sha256()
            .hashString(canonical, utf8)
            .toString()

        // Get only the 'date' of the date-time string, i.e. 20200221 for 21/02/2020.
        val date = amzDate.substring(0, 8)
        val dateCredential = String.format(
            "%s/%s/s3/aws4_request",
            date, BUCKET_REGION
        )

        // This is the data we need to sign for the server to accept our request as valid.
        val toSign = String.format(
            "AWS4-HMAC-SHA256\n%s\n%s\n%s",
            amzDate, dateCredential, messageDigest
        )

        // To generate the signing key is a four-step process. The key is generated by hashing the
        // date first, then the region with the date key, the service code with this region key,
        // and then the word 'aws4_request' is hashed with this service code key.
        val dateKey = Hashing.hmacSha256(("AWS4$API_KEY").toByteArray(utf8))
            .hashString(date, utf8)
            .asBytes()
        val dateRegionKey = Hashing.hmacSha256(dateKey)
            .hashString(BUCKET_REGION, utf8)
            .asBytes()
        val dateRegionServiceKey = Hashing.hmacSha256(dateRegionKey)
            .hashString("s3", utf8)
            .asBytes()
        val signingKey = Hashing.hmacSha256(dateRegionServiceKey)
            .hashString("aws4_request", utf8)
            .asBytes()

        // Use this signing key to generate the signature to sign the request with.
        val signature = Hashing.hmacSha256(signingKey)
            .hashString(toSign, utf8)
            .toString()
        val credential = String.format(
            "%s/%s",
            ACCESS_KEY, dateCredential
        )
        return String.format(
            "AWS4-HMAC-SHA256 Credential=%s, " +
                    "SignedHeaders=host;x-amz-content-sha256;x-amz-date, " +
                    "Signature=%s", credential, signature
        )
    }// Based on: https://github.com/aws/aws-sdk-java/blob/master/aws-java-sdk-core/
    //              src/test/java/com/amazonaws/auth/AWS4SignerTest.java
    /**
     * Get the current date and time as the x-amz-date format, required for signing requests.
     *
     * @return the String for the x-amz-date field
     */
    private val amzDate: String
        get() {
            // Based on: https://github.com/aws/aws-sdk-java/blob/master/aws-java-sdk-core/
            //              src/test/java/com/amazonaws/auth/AWS4SignerTest.java
            val dateTimeFormat = SimpleDateFormat(
                "yyyyMMdd'T'HHmmss'Z'", Locale.ENGLISH
            )
            dateTimeFormat.timeZone = SimpleTimeZone(0, "UTC")
            return dateTimeFormat.format(Date())
        }

    /**
     * Send an HTTP HEAD request for the S3 object given by the path. A HEAD request is similar to
     * a GET request, but instead only returns metadata about the object.
     *
     * @param path to the item in the S3 bucket
     * @return HTTP headers detailing the object's metadata
     */
    private fun head(path: String): Headers? {
        val amzDate = amzDate
        val request: Request = Request.Builder()
            .url(BUCKET_URL + path)
            .head()
            .addHeader(
                "Authorization",
                getAuthorisationHeader(path, amzDate, "HEAD")
            )
            .addHeader("x-amz-content-sha256", EMPTY_PAYLOAD_HASH)
            .addHeader("x-amz-date", amzDate)
            .build()
        try {
            okHttpClient.newCall(request).execute().use { response ->
                if (response.isSuccessful) {
                    return response.headers
                } else {
                    val body = response.body
                    Log.e(
                        TAG, String.format(
                            "head: request was not successful (status %d): %s",
                            response.code, body?.string() ?: "NO BODY!"
                        )
                    )
                    Log.e(TAG, "head: further headers: " + response.headers)
                }
            }
        } catch (e: IOException) {
            Log.e(TAG, "head: IOException: " + e.localizedMessage)
        }
        return null
    }

    /**
     * Get an object from the S3 bucket given by the path.
     *
     * @param path to item in the S3 bucket
     * @return the file's contents
     */
    private operator fun get(path: String): String? {
        val amzDate = amzDate
        val request: Request = Request.Builder()
            .url(BUCKET_URL + path)
            .addHeader(
                "Authorization",
                getAuthorisationHeader(path, amzDate, "GET")
            )
            .addHeader("x-amz-content-sha256", EMPTY_PAYLOAD_HASH)
            .addHeader("x-amz-date", amzDate)
            .build()
        try {
            okHttpClient.newCall(request).execute().use { response ->
                val body = response.body
                if (response.isSuccessful) {
                    return body?.string()
                } else {
                    Log.e(
                        TAG, String.format(
                            "get: request was not successful (status %d): %s",
                            response.code, body?.string() ?: "NO BODY!"
                        )
                    )
                }
            }
        } catch (e: IOException) {
            Log.e(TAG, "get: IOException: " + e.localizedMessage)
        }
        return null
    }

    /**
     * Get the date of when the object was last modified in the S3 bucket.
     *
     * @param path to item in the S3 bucket
     * @return the date when the object was last modified
     */
    private fun getLastModified(path: String): Date? {
        val headers = head(path)
        return headers?.getDate("Last-Modified")
    }

    /**
     * Get the JSON file containing the list of events.
     *
     * @return the list of events as a JSON string
     */
    val eventsJson: String?
        get() = GuildEventsS3["events.json"]

    /**
     * Get the date the events.json file was last modified in the S3 bucket.
     *
     * @return the date of last modification
     */
    val eventsJsonLastModified: Date?
        get() = getLastModified("events.json")

    /**
     * Get the JSON file containing the list of event organisers.
     *
     * @return the list of event organisers as a JSON string
     */
    val organisationsJson: String?
        get() = GuildEventsS3["organisations.json"]

    /**
     * Get the date the organisations.json file was last modified in the S3 bucket.
     *
     * @return the date of last modification
     */
    val organisationsLastModified: Date?
        get() = getLastModified("organisations.json")
}